###### 1. Round Robin
~~~
// Round Robin
//
// 一个处理器要处理一堆request，一次只能处理一条，每次执行一个任务最多执行时间q，接着执行等待着的下一个任务。若前一个任务没执行完则放到队尾，等待下一次执行
//
// 假设只要有任务开始以后cpu是不会空闲的，也就是说cpu开始后如果空闲了就说明没有任务了，另外Robin Round最后返回值是float

import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */

class Solution {
  public static void main(String[] args) {
    int[] arrival1 = {0, 1, 4};
    int[] run1 = {5, 2, 3};
    int q1 = 3;
    System.out.println(estimateTime(arrival1, run1, q1));
    System.out.println(estimate(arrival1, run1, q1));

    int[] arrival2 = {0, 1, 3, 9};
    int[] run2 = {2, 1, 7, 5};
    int q2 = 2;
    System.out.println(estimateTime(arrival2, run2, q2));
    System.out.println(estimate(arrival2, run2, q2));
  }

  public static class Process {
    int aTime;
    int eTime;

    Process(int aTime, int eTime) {
      this.aTime = aTime;
      this.eTime = eTime;
    }
  }

  public static float estimateTime(int[] aTimes, int[] eTimes, int q) {
    if (aTimes == null || eTimes == null || aTimes.length != eTimes.length) {
      return 0;
    }

    Deque<Process> deque = new ArrayDeque<Process>();
    int currTime = 0;
    int waitTime = 0;
    int idx = 0;
    int len = aTimes.length;
    while (!deque.isEmpty() || idx < len) {
      if (!deque.isEmpty()) {
        Process p = deque.poll();
        waitTime += currTime - p.aTime;
        currTime += Math.min(p.eTime, q);
        // inqueue tasks
        while (idx < len && aTimes[idx] <= currTime) {
          deque.offer(new Process(aTimes[idx], eTimes[idx]));
          idx++;
        }

        // if the execution time is longer than p
        if (p.eTime > q) {
          deque.offer(new Process(currTime, p.eTime - q));
        }
      } else {
        deque.offer(new Process(aTimes[idx], eTimes[idx]));
        currTime = aTimes[idx++];
      }
    }

    return (float) waitTime / len;
  }

  public static float estimate(int[] Atime, int[] Etime, int q) {
      if (Atime == null || Etime == null || Atime.length != Etime.length)
          return 0;
      int length = Atime.length;
      Queue<Process> queue = new LinkedList<Process>();
      int curTime = 0, waitTime = 0;
      int index = 0;
      while (!queue.isEmpty() || index < length) {
          if (!queue.isEmpty()) {
              Process cur = queue.poll();
              waitTime += curTime - cur.aTime;
              curTime += Math.min(cur.eTime, q);
              for (; index < length && Atime[index] <= curTime; index++)
                  queue.offer(new Process(Atime[index], Etime[index]));
              if (cur.eTime > q)
                  queue.offer(new Process(curTime, cur.eTime - q));
          }
          else {
              queue.offer(new Process(Atime[index], Etime[index]));
              curTime = Atime[index++];
          }
      }
      return (float) waitTime / length;
  }
}
~~~

###### 2. Rotate Image
~~~
import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */

class Solution {
  public static void main(String[] args) {
      int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
      matrix = rotate(matrix, 1);
      for (int[] row : matrix) System.out.println(Arrays.toString(row));

      int[][] matrix1 = {{1,2,3},{4,5,6},{7,8,9}};
      matrix1 = rotate(matrix1, 0);
      for (int[] row : matrix1) System.out.println(Arrays.toString(row));
  }

  public static int[][] rotate(int[][] matrix, int flag) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0
           || (flag != 1 && flag != 0)) {
            return matrix;
        }
        int m = matrix.length, n = matrix[0].length;

        if (flag == 1) {
            int[][] clockwise = new int[n][m];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    clockwise[j][m - 1 - i] = matrix[i][j];
                }
            }
            return clockwise;
        }
        else {
            int[][] clock = new int[n][m];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    clock[n - 1 - j][i] = matrix[i][j];
                }
            }
            return clock;
        }
    }
}
~~~

###### 3. BST minimum sum from root to leaf
~~~
public class PathSum {
    public int Solution(TreeNode root) {
        if (root == null)   return 0;
        if (root.left != null && root.right == null)
            return Solution(root.left) + root.val;
        if (root.left == null && root.right != null)
            return Solution(root.right) + root.val;
        return Math.min(Solution(root.left), Solution(root.right)) + root.val;
    }
}
~~~

###### 4. Insert value into a circle linked-list
~~~
public class LinkedListInsert {
    public ListNode Solution(ListNode head, int val) {
        if (head == null) {
            ListNode rvalue = new ListNode(val);
            rvalue.next = rvalue;
            return rvalue;
        }

        ListNode cur = head;

        do {
            if (val <= cur.next.val && val >= cur.val)  break;
            if (cur.val > cur.next.val && (val < cur.next.val || val > cur.val))    break;
            cur = cur.next;
        } while (cur != head);

        ListNode newNode = new ListNode(val);
        newNode.next = cur.next;
        cur.next = newNode;
        return newNode;
    }
}
~~~

###### 5. GCD
~~~
import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */

class Solution {
    public static void main(String[] args) {
        int[][] arrays = {{13,23,56,89,100,232,23,56,0}, {54,36,48,84,168}, {21,7,28,56,112},{16,20,92,1000,200}};
        for (int[] array : arrays) {
            System.out.println(GCD(array));
            System.out.println(method1(array));
        }
    }

    public static int GCD(int[] array) {
        if (array == null || array.length == 0) return 0;
        int gcd = array[0];
        for (int i = 1; i < array.length; i++) {
            gcd = helper(gcd, array[i]);
        }
        return gcd;
    }

    // gcd(a, b) = gcd(a, a % b)
    private static int helper(int num1, int num2) {
        if (num1 == 0 || num2 == 0) return 0;
        while (num2 != 0) {
            int c = num2;
            num2 = num1 % num2;
            num1 = c;
        }

        return num1;
    }

    //===================================================
    public static int method1(int[] array) {
        if (array == null || array.length == 1) return 0;
        int gcd = array[0];
        for (int i = 1; i < array.length; i++) {
            gcd = helper1(gcd, array[i]);
        }
        return gcd;
    }

    private static int helper1(int num1, int num2) {
        if (num1 == 0 || num2 == 0) return 0;
        while (num1 != 0 && num2 != 0) {
            if (num2 > num1) {
                num1 ^= num2;
                num2 ^= num1;
                num1 ^= num2;
            }
            int temp = num1 % num2;
            num1 = num2;
            num2 = temp;
        }
        return num1 + num2;
    }
}
~~~

###### 6. Shorted job first
~~~
// 一个处理器要处理一堆request，一次只能处理一条，如果它有几个积压着的requests，它会先执行持续时间短的那个；对于持续时间相等的requests，先执行最早到达处理器的request。问平均每个request要等多久才能被处理。input：requestTimes[]，每个request到达处理器的时间; durations[] 每个request要处理的持续时间。 两个数组是一一对应的，并已按requestTimes[] 从小到大排序过
//
// public double CalWaitingTime(int requestTimes[], int[] durations[]){}
//
// 用priorityqueue做，地里有一个两层循环的答案，没仔细看，做完round robin以后发现思路很相似。注意用priorityqueue写comparator的时候，要先判断两者的execute time,如果execute time相同，则返回arrival time之差，即先按执行时间排序，若执行时间相同则按到达的时间排。

import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */

class Solution {
    public static void main(String[] args) {
        int[][] requestTimes = {{0, 2, 4, 5}, {0, 1, 3, 9}};
        int[][] durations = {{7, 4, 1, 4}, {2, 1, 7, 5}};
        for (int i = 0; i < requestTimes.length; i++) {
            System.out.println(calWaitingTime(requestTimes[i], durations[i]));
        }
    }

    public static class Process {
        int requestTime;
        int duration;

        Process(int requestTime, int duration) {
            this.requestTime = requestTime;
            this.duration = duration;
        }
    }

    public static double calWaitingTime(int[] requestTimes, int[] durations) {
        if (requestTimes == null || requestTimes.length == 0
           || durations == null || durations.length == 0
            || requestTimes.length != durations.length) {
            return 0;
        }

        PriorityQueue<Process> pq = new PriorityQueue<Process>(new Comparator<Process>() {
            @Override
            public int compare(Process p1, Process p2) {
                if (p1.duration == p2.duration) {
                    return Integer.compare(p1.requestTime, p2.requestTime);
                }
                return Integer.compare(p1.duration, p2.duration);
            }
        });

        int index = 0;
        int len = requestTimes.length;
        int waitTime = 0;
        int currTime = 0;

        while (!pq.isEmpty() || index < len) {
            if (!pq.isEmpty()) {
                Process p = pq.poll();
                waitTime += currTime - p.requestTime;
                currTime += p.duration;

                // inqueue processes whose requestTime <= currTime
                while (index < len && requestTimes[index] <= currTime) {
                    pq.offer(new Process(requestTimes[index], durations[index]));
                    index++;
                }
            }
            else {
                pq.offer(new Process(requestTimes[index], durations[index]));
                currTime = requestTimes[index];
                index++;
            }
        }

        return (double) waitTime / len;
    }
}
~~~

###### 7. LRU Cache Count miss
~~~
import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */

class Solution {
    public static void main(String[] args) {
        int[][] tests = {{1,1,2,4,5,3,4,5,6,6,4,5}, {1,1,1,1,2,2,2,2,4,3,3,3,2,3,2,5,6,2,10}};
        for (int[] test : tests) {
            System.out.println(countCacheMiss(test, 3));
            System.out.println(countCacheMiss2(test, 3));
        }
    }

    public static int countCacheMiss(int[] array, int size) {
        if (array == null) {
            return 0;
        }
        LRUCache cache = new LRUCache(size);
        int count = 0;
        for (int num : array) {
            if (!cache.get(num)) {
                count++;
                cache.put(num);
            }
        }
        return count;
    }

    public static int countCacheMiss2(int[] array, int size) {
        if (array == null)  return 0;
        List<Integer> cache = new LinkedList<Integer>();
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (cache.contains(array[i])) {
                cache.remove(new Integer(array[i]));
            }
            else {
                count++;
                if (size == cache.size())
                    cache.remove(0);
            }
            cache.add(array[i]);
        }
        return count;
    }

    @SuppressWarnings("serial")
    public static class LRUCache {
        LinkedHashMap<Integer, Boolean> map;
        final int CAPACITY;

        public LRUCache(int capacity) {
            CAPACITY = capacity;
            map = new LinkedHashMap<Integer, Boolean>(CAPACITY, 0.75F, true) {
                protected boolean removeEldestEntry(Map.Entry<Integer, Boolean> entry){
                    return size() > CAPACITY;
                }
            };
        }

        public boolean get(int key) {
            return map.getOrDefault(key, false);
        }

        public void put(int key) {
            map.put(key, true);
        }
    }
}
~~~

###### 8. Day change
~~~
class Solution {
    public static void main(String[] args) {
        int[][] tests = {{1,1,0,0,1,1,1,0,1,0,1}, {1,1,1,1,0,0,1,0,0,1,0,1,0,1}, {1, 0, 0, 0, 0, 1, 0, 0}};
        for (int[] test : tests) {
            System.out.println(Arrays.toString(dayChange(test, 7)));
            // System.out.println(Arrays.toString(dayChange2(test, 7)));
            System.out.println(Arrays.toString(change5(test, 7)));
        }
    }

    public static int[] dayChange(int[] cells, int days) {
        if (cells == null || cells.length <= 1
            || days <= 0) return cells;

        int len = cells.length;
        int[] nums = new int[len];
        for (int i = 0; i < len; i++) {
            nums[i] = cells[i];
        }

        for (int i = 0; i < days; i++) {
            int prev = nums[0];
            nums[0] = (nums[1] == 0 ? 0 : 1);
            for (int j = 1; j < len - 1; j++) {
                int temp = nums[j];
                nums[j] = (prev == nums[j + 1] ? 0 : 1);
                prev = temp;
            }
            nums[len - 1] = (prev == 0 ? 0 : 1);
        }

        return nums;
    }

    public static int[] change5(int[] arr, int days) {
           if (arr == null || arr.length <= 1 || days <= 0) {
                return arr;
           }
           int len = arr.length;
           // preNum represents previous day's list
           int[] preNum = new int[len];
           preNum = arr;
           for (int cnt = 0; cnt < days; cnt++) {
                int[] curNum = new int[len];
                curNum[0] = preNum[1];
                curNum[len - 1] = preNum[len - 2];
                for (int i = 1; i < len - 1; i++) {
                      curNum[i] = preNum[i - 1] ^ preNum[i + 1];
                }
                preNum = curNum;
           }
           return preNum;
     }
}
~~~

###### 9. Find path in maze
~~~
class Solution {
    public static void main(String[] args) {
        int[][] tests = {{1,1,0,1,1},{1,1,0,9,1},{0,1,1,1,1},{0,1,1,1,1}};
        System.out.println(maze(tests));
    }

    public static int maze(int[][] matrix) {
        if (matrix == null || matrix.length == 0
            || matrix[0].length == 0) {
            return 0;
        }
        if (dfs(matrix, new boolean[matrix.length][matrix[0].length], 0, 0)) {
            return 1;
        }
        return 0;
    }

    private static boolean dfs(int[][] matrix, boolean[][] visited, int row, int col) {
        visited[row][col] = true;
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        for (int[] dir : dirs) {
            int x = row + dir[0];
            int y = col + dir[1];
            if (x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length
               && !visited[x][y]) {
                if (matrix[x][y] == 9) return true;
                else if (matrix[x][y] == 1 && dfs(matrix, visited, x, y)) return true;
            }
        }

        return false;
    }
}
~~~

###### 10. Check subtree
~~~
public class Subtree {
    public boolean isSubTree(TreeNode T1, TreeNode T2) {
        if (T2 == null) return true;
        if (T1 == null) return false;
        return (isSameTree(T1,T2) || isSubTree(T1.left, T2) || isSubTree(T1.right, T2));
    }
    public boolean isSameTree(TreeNode T1, TreeNode T2) {
        if (T1 == null && T2 == null)
            return true;
        if (T1 == null || T2 == null)
            return false;
        if (T1.val != T2.val)
            return false;
        return (isSameTree(T1.left, T2.left) && isSameTree(T1.right, T2.right));
    }
}
~~~

###### 11. Valid Parenthesis
~~~
class Solution {
    public static void main(String[] args) {
        String[] tests = {"(()(){}[])", "()[{[]}]", "()([])[)]"};
        for (String str : tests) {
            System.out.println(isValid(str));
        }
    }

    public static int isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{') {
                stack.push(s.charAt(i));
            }
            else if (s.charAt(i) == ')') {
                if (stack.empty() || stack.pop() != '(') return -1;
            }
            else if (s.charAt(i) == ']') {
                if (stack.empty() || stack.pop() != '[') return -1;
            }
             else if (s.charAt(i) == '}') {
                if (stack.empty() || stack.pop() != '{') return -1;
            }
        }
        if(!stack.empty()) return -1;
        return s.length() / 2;
    }
}
~~~

###### 12. Reverse second half of linked list
~~~
class Solution {
    public static void main(String[] args) {
        int[][] tests = {{1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}, {1,2,3,4,5,6}, {1,2,3,4,5,6,7}};
        for (int[] test : tests) {
            ListNode head = buildList(test);
            printList(reverseHalfList(head));
        }
    }

    public static void printList(ListNode head) {
        ListNode curr = head;
        while (curr.next != null) {
            System.out.print(curr.val + "->");
            curr = curr.next;
        }
        System.out.println(curr.val);
    }

    public static ListNode buildList(int[] nums) {
        ListNode head = new ListNode(nums[0]);
        ListNode curr = head;
        for (int i = 1; i < nums.length; i++) {
            curr.next = new ListNode(nums[i]);
            curr = curr.next;
        }
        return head;
    }

    static class ListNode {
        int val;
        ListNode next;

        ListNode(int val) {
            this.val = val;
        }
    }

    public static ListNode reverseHalfList(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        slow.next = reverseList(slow.next);
        return head;
    }

    private static ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode prev = head;
        ListNode curr = head.next;
        head.next = null;
        ListNode next = null;
        while (curr != null) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }

        return prev;
    }
}
~~~


###### 13. Same Tree
~~~
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if ((p == null && q != null) || (p != null && q == null)) {
            return false;
        }
        if (p.val != q.val) {
            return false;
        }
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}

~~~

###### 14. arithmetic sequence
~~~
/*
	int[] A = {2,5,2,3,4,6,8,10,12,9,8,7,6,2,4,8};
	OA2: find out number of arithmetic sequence in array
	time complexity: O(n)
	space complexity: O(1)
*/
public class ArithmaticSlice{
	public static int Solution(int[] nums) {
		if(nums == null || nums.length < 3) return 0;
		int left = 0, right = 1, diff = nums[1] - nums[0], count = 0;
		while(right < nums.length - 1){
			if(diff != nums[right + 1] - nums[right]){
				count += (right - left - 1) * (right - left) / 2;
				if(count > 1000000000) return -1;
				diff = nums[right + 1] - nums[right];
				left = right;
			}
			++right;
		}
		count += (right - left - 1) * (right - left) / 2;
		return count > 1000000000 ? -1 : count;
	}
}
~~~
