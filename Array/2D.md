The file summarizes problems involved 2D board.

# DP
## 64. Minimum Path Sum (Medium)
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

#### Solution
1. Naiive 2D DP
2. 1D DP
3. DP without extra space when we don't need to retain input matrix

Version 1 <br>
Attempts: 2 (typo bug)
~~~
public class Solution {
    public int minPathSum(int[][] grid) {
        // edge cases
        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;

        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[m][n];

        // init
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (int j = 1; j < n; j++) {
            // dp[0][j] = dp[0][j - 1] + dp[0][j]; // bug typo
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[m - 1][n - 1];
    }
}
~~~

Version 2 <br>
Attempts: 2 (bug when setting initial value of prev for each row)
~~~
public class Solution {
    public int minPathSum(int[][] grid) {
        // edge cases
        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;

        int m = grid.length, n = grid[0].length;
        int[] dp = new int[n];

        // init
        dp[0] = grid[0][0];
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            // int prev = grid[i][0]; // bug
            int prev = grid[i][0] + dp[0];
            dp[0] = prev;
            for (int j = 1; j < n; j++) {
                int curr = Math.min(dp[j], prev) + grid[i][j];
                // update dp array and prev
                dp[j] = curr;
                prev = curr;
            }
        }

        return dp[n - 1];
    }
}
~~~

Version 3 <br>
Attempts: 2 (minor typo bug)
~~~
public class Solution {
    public int minPathSum(int[][] grid) {
        // edge cases
        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;

        int m = grid.length, n = grid[0].length;

        // init
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }

        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }

        return grid[m - 1][n - 1];
    }
}
~~~

~~~
SNAPCHAT的面经题
但不同的是LC上只要求你给出MIN PATH SUM是多少就行， 而SNAPCHAT貌似要你输出所有可能的MINIMUM PATH SUM路径。这个题怎么做？
链接: https://instant.1point3acres.com/thread/198644
来源: 一亩三分地
~~~

# DFS & BFS
## 490. The Maze
There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.

#### Solution
1. DFS
2. BFS
**Use Arrays.equals()**

DFS recursion <br>
Attempt: 1 <br>
~~~
public class Solution {
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        if (maze == null || maze.length == 0 || maze[0].length == 0) return false;
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        return dfs(maze, start, destination, visited);
    }

    private boolean dfs(int[][] maze, int[] start, int[] destination, boolean[][] visited) {
        // base case
        if (Arrays.equals(start, destination)) {
            return true;
        }

        int m = maze.length; // the height
        int n = maze[0].length; // the width

        visited[start[0]][start[1]] = true;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int[] dir : dirs) {
            int x = start[0];
            int y = start[1];
            while (x + dir[0] >= 0 && x + dir[0] < m && y + dir[1] >= 0 && y + dir[1] < n
                && maze[x + dir[0]][y + dir[1]] != 1) {
                x += dir[0];
                y += dir[1];
            }
            int[] point = {x, y};
            if (!visited[x][y] && dfs(maze, point, destination, visited)) return true;
        }

        return false;
    }
}
~~~

BFS queue <br>
~~~
public class Solution {
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        if (maze == null || maze.length == 0 || maze[0].length == 0) return false;

        int m = maze.length;
        int n = maze[0].length;

        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        boolean[][] visited = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(start);
        visited[start[0]][start[1]] = true;

        while (!queue.isEmpty()) {
            int[] p = queue.poll();

            if (Arrays.equals(p, destination)) return true;

            for (int[] dir : dirs) {
                int x = p[0];
                int y = p[1];
                while (x + dir[0] >= 0 && x + dir[0] < m && y + dir[1] >= 0 && y + dir[1] < n
                    && maze[x + dir[0]][y + dir[1]] != 1) {
                    x += dir[0];
                    y += dir[1];
                }
                if (!visited[x][y]) {
                    int[] next = {x, y};
                    queue.offer(next);
                    visited[x][y] = true;
                }
            }
        }

        return false;
    }
}
~~~

## 505. The Maze II
There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the ball's start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.

1. BFS use PriorityQueue
2. DFS

BFS <br>
Attempt: 5 (bug should return -1 if the ball cannot stop at the destination)
~~~
public class Solution {
    class Point {
        int x;
        int y;
        int d;

        Point(int x, int y, int d) {
            this.x = x;
            this.y = y;
            this.d = d;
        }
    }

    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        int m = maze.length;
        int n = maze[0].length;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};

        int[][] dist = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dist[i], -1);
        }

        PriorityQueue<Point> pq = new PriorityQueue<Point>(new Comparator<Point>() {
            public int compare(Point x, Point y) {
                return x.d - y.d;   
            }
        });
        pq.offer(new Point(start[0], start[1], 0));

        while (!pq.isEmpty()) {
            Point p = pq.poll();
            for (int[] dir : dirs) {
                int x = p.x;
                int y = p.y;
                int d = p.d;
                while (x + dir[0] >= 0 && x + dir[0] < m && y + dir[1] >= 0 && y + dir[1] < n
                    && maze[x + dir[0]][y + dir[1]] != 1) {
                        x += dir[0];
                        y += dir[1];
                        d++;
                }

                if (dist[x][y] == -1 || d < dist[x][y]) {
                    dist[x][y] = d;
                    pq.offer(new Point(x, y, d));
                }
            }
        }

        return dist[destination[0]][destination[1]];
    }
}
~~~

DFS slow <br>
~~~
public class Solution {

    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        int m = maze.length; // the height
        int n = maze[0].length; // the width
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dist[i], -1);
        }
        dist[start[0]][start[1]] = 0;
        dfs(maze, start, destination, dist);
        // return dist[m - 1][n -1]; // --!
        return dist[destination[0]][destination[1]];
    }

    private void dfs(int[][] maze, int[] start, int[] destination, int[][] dist) {
        // base case
        if (Arrays.equals(start, destination)) {
            return;
        }

        int m = maze.length; // the height
        int n = maze[0].length; // the width

        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int[] dir : dirs) {
            int x = start[0];
            int y = start[1];
            int d = dist[start[0]][start[1]];
            while (x + dir[0] >= 0 && x + dir[0] < m && y + dir[1] >= 0 && y + dir[1] < n
                && maze[x + dir[0]][y + dir[1]] != 1) {
                x += dir[0];
                y += dir[1];
                d++;
            }
            if (dist[x][y] == -1 || d < dist[x][y]) {
                dist[x][y] = d;
                int[] point = {x, y};
                dfs(maze, point, destination, dist);
            }
        }
    }
}
~~~

## 499. The Maze III (Hard)*
There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r), but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls on to the hole.

Given the ball position, the hole position and the maze, find out how the ball could drop into the hole by moving the shortest distance. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the hole (included). Output the moving directions by using 'u', 'd', 'l' and 'r'. Since there could be several different shortest ways, you should output the lexicographically smallest way. If the ball cannot reach the hole, output "impossible".

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.

#### Solution
由于题目要求输出the lexicographically smallest way，所以在II的基础上修改Point类，实现compareTo函数，在比较两个Point大小的时候，同时对比distance和str两个属性。

**注意Java的一些常用语法，比如implements Comparable, public int compareTo()等**

~~~
public class Solution {
    class Point implements Comparable<Point> {
        int x;
        int y;
        int d;
        String str;

        Point(int x, int y, int d, String str) {
            this.x = x;
            this.y = y;
            this.d = d;
            this.str = str;
        }

        public int compareTo(Point p) {
            if (this.d == p.d) return this.str.compareTo(p.str);
            return this.d - p.d;
        }
    }

    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {
        List<String> ans = new ArrayList<String>();

        int m = maze.length; // height
        int n = maze[0].length; //width

        Point[][] points = new Point[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                points[i][j] = new Point(i, j, Integer.MAX_VALUE, "");
            }
        }
        points[ball[0]][ball[1]].d = 0;

        PriorityQueue<Point> pq = new PriorityQueue<Point>();
        pq.offer(new Point(ball[0], ball[1], 0, ""));

        int[][] dirs = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}}; // down, left, right, up
        char[] paths = {'d', 'l', 'r', 'u'};
        while (!pq.isEmpty()) {
            Point p = pq.poll();

            for (int i = 0; i < dirs.length; i++) {
                int[] dir = dirs[i];
                char ch = paths[i];

                int x = p.x;
                int y = p.y;
                int d = p.d;
                StringBuilder sb = new StringBuilder(p.str);

                while (x + dir[0] >= 0 && x + dir[0] < m && y + dir[1] >= 0 && y + dir[1] < n
                    && maze[x + dir[0]][y + dir[1]] != 1 && !(x == hole[0] && y == hole[1])) {
                    x += dir[0];
                    y += dir[1];
                    d++;
                }

                sb.append(ch);
                Point next = new Point(x, y, d, sb.toString());
                if (points[x][y].compareTo(next) > 0) {
                    points[x][y] = next;
                    pq.offer(next);
                }
            }
        }

        return points[hole[0]][hole[1]].str.equals("") ? "impossible" : points[hole[0]][hole[1]].str;
    }
}
~~~

# Binary Index Tree and Segment Tree
## 303. Range Sum Query - Immutable (Easy)
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:
~~~
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
~~~

Note:
You may assume that the array does not change.
There are many calls to sumRange function.

#### Solution
Easy one.

**注意生成sum数组时，int[] sums = new int[len + 1], 和edge cases的处理**

~~~
public class NumArray {

    int[] sums;

    public NumArray(int[] nums) {
        if (nums == null || nums.length == 0) return;

        this.sums = new int[nums.length + 1];
        sums[0] = 0;
        for (int i = 1; i < nums.length + 1; i++) {
            sums[i] = nums[i - 1] + sums[i - 1];
        }
    }

    public int sumRange(int i, int j) {
        if (i < 0) i = 0;
        if (j >= sums.length - 1) j = sums.length - 2;

        return sums[j + 1] - sums[i];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(i,j);
 */
 ~~~

## 307. Range Sum Query - Mutable
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

The update(i, val) function modifies nums by updating the element at index i to val.
Example:
~~~
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
~~~
Note:
The array is only modifiable by the update function.
You may assume the number of calls to update and sumRange function is distributed evenly.

#### Solution
1. 这题简单的方法很容易想到，但是面临的代价是要么update O(n)，getSum O(1)；要么update O(1), getSum O(n), 题目中说明You may assume the number of calls to update and sumRange function is distributed evenly, 如何做到update和getSum两个操作的耗时even是关键
2. 这题引入两个数据结构segment tree和BIT， geeksforgeeks网站上有很好的解释，这样可以把getSum和update的复杂度都讲到O(logn)

###### Segment Tree
类似于二分，根节点存[0-n]的sum, 然后分成左右子树，左结点存[0-n/2]的sum，右结点错[n/2-n]的sum，然后递归生成左右子树。<br>
**复杂度分析，初期建树，总共有O(2n-1)个结点，space O(2n-1), time O(2n-1)**；每次查询和更新的复杂度都是O(logn)

###### BIT
1. The idea of BIT is that every positive integer can be represented using power of 2, e.g. 12 can be represented as 8 + 4. So, if we want to get the sum(0, 12), what we can do is sum(0, 8) + sum(8, 12).
2. For getSum query, we can build BIT that the parent of a node (i) is with index i - (i & (-i)), e.g. the parent index of node(12) is 8. The value of every node is the sum from its parent (exclusive) to the the node (inclusive), e.g. node(12) has a value of sum(9, 12). Therefore, for getSum(12), we add up node with index 12, and parent nodes index - (index & (-index))
3. For update operation, e.g. if we update num[0], we need to update all nodes have value range from 0 to itself, let's say it is a array of length 12, so we need to update node(1), node(2), node(4), node(8). Therefore, for update(0), the starting index is node(1), and we will also update all nodes with index + (index & (-index)).

BIT cost O(n + 1) space, and build tree cost O(nlogn) time. Each update and getSum is O(logn)

Attempts: 4
~~~
public class NumArray {
    private int[] nums;
    private int[] BIT;

    public NumArray(int[] nums) {
        if (nums == null || nums.length == 0) return;
        int n = nums.length;
        this.nums = new int[n];
        BIT = new int[n + 1];
        for (int i = 0; i < n; i++) {
            update(i, nums[i]);
        }  
    }

    public void update(int i, int val) {
        int diff = val - nums[i];
        nums[i] = val;
        for (int j = i + 1; j < BIT.length; j += j & (-j)) {
            BIT[j] += diff;
            // System.out.println(BIT[j]);
        }
    }

    public int sumRange(int i, int j) {
        if (i < 0) i = 0;
        if (j > nums.length) j = nums.length - 1;
        return sumRangeHelper(j) - sumRangeHelper(i) + nums[j];
    }

    private int sumRangeHelper(int i) {
        int sum = 0;
        for (int j = i; j > 0; j -= j & (-j)) {
            sum += BIT[j];
        }
        return sum;
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(i,j);
 */
~~~

## 304. Range Sum Query 2D - Immutable
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

Example:
~~~
Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12
~~~

#### Solution
1. 注意生成2D的sums数组长宽分别+1

Attempts: 2 （处理edge cases花了些时间，面试的时候和面试官确认）
~~~
public class NumMatrix {

    int[][] sums;

    public NumMatrix(int[][] matrix) {
        // edge case
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            sums = new int[0][0];
            return;    
        }

        sums = new int[matrix.length + 1][matrix[0].length + 1];
        for (int i = 1; i < sums.length; i++) {
            for (int j = 1; j < sums[0].length; j++) {
                sums[i][j] = matrix[i - 1][j - 1] + sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        // edge cases
        // You may assume that row1 ≤ row2 and col1 ≤ col2.
        if (sums.length == 0 || sums[0].length == 0) return 0;
        if (row1 < 0) row1 = 0;
        if (row2 < 0) return 0;
        if (col1 < 0) col1 = 0;
        if (col2 < 0) return 0;

        if (row2 >= sums.length) row2 = sums.length - 1;
        if (row1 >= sums.length) return 0;
        if (col2 >= sums[0].length) col2 = sums[0].length - 1;
        if (col1 >= sums[0].length) return 0;

        return sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] - sums[row2 + 1][col1] + sums[row1][col1];
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
 ~~~


## 308. Range Sum Query 2D - Mutable

Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

Example:
~~~
Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
update(3, 2, 2)
sumRegion(2, 1, 4, 3) -> 10
~~~

Note:
The matrix is only modifiable by the update function.
You may assume the number of calls to update and sumRegion function is distributed evenly.
You may assume that row1 ≤ row2 and col1 ≤ col2.

#### Solution
1. 2D BIT
2. 2D Segment Tree

Attempts: 4 注意调用getSum的边界
~~~
public class NumMatrix {
    int[][] matrix;
    int[][] sums;

    public NumMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }

        this.matrix = new int[matrix.length][matrix[0].length];
        this.sums = new int[matrix.length + 1][matrix[0].length + 1];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                update(i, j, matrix[i][j]);
            }
        }
    }

    public void update(int row, int col, int val) {
        // edge case
        if (matrix == null) return;

        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length) return;
        int diff = val - matrix[row][col];
        matrix[row][col] = val;
        for (int i = row + 1; i < sums.length; i += i & (-i)) {
            for (int j = col + 1; j < sums[0].length; j += j & (-j)) {
                sums[i][j] += diff;
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        // edge cases
        if (sums == null) return 0;
        // You may assume that row1 ≤ row2 and col1 ≤ col2.
        if (row2 < 0 || row1 >= matrix.length || col2 < 0 || col1 >= matrix[0].length) return 0;
        if (row1 < 0) row1 = 0;
        if (col1 < 0) col1 = 0;
        if (row2 >= matrix.length) row2 = matrix.length - 1;
        if (col2 >= matrix[0].length) col2 = matrix[0].length - 1;

        return getSum(row2 + 1, col2 + 1) - getSum(row1, col2 + 1) - getSum(row2 + 1, col1) + getSum(row1, col1);

    }

    private int getSum(int row, int col) {
        int ans = 0;
        for (int i = row; i > 0; i -= i & (-i)) {
            for (int j = col; j > 0; j -= j & (-j)) {
                ans += sums[i][j];
            }
        }
        return ans;
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * obj.update(row,col,val);
 * int param_2 = obj.sumRegion(row1,col1,row2,col2);
 */
~~~
